<script>
    window._inspectionsDataDispatched = window._inspectionsDataDispatched || false;
    function s3DataLoader() {
      return {
        dataSourceURL: {{ .Param "data.source" | default "" }},
        showPopup: {{ .Param "data.popup" | default "false" }},
        cacheVersion: {{ .Param "data.cacheVersion" | default 1 }},
        maxCacheAge: {{ .Param "data.maxCacheAge" | default 24 }} * 60 * 60 * 1000,
        delimiter: {{ .Param "data.delimiter" | default "," }},
        numericFields: {{ .Param "data.numericFields" | default "[]" }},
        cacheName: '',
        dbName: 'SpotlightPA-DataCache',
        loading: false,
        loadingProgress: 0,
        loadingMessage: 'Initializing...',
        error: null,
        data: [],
        retryCount: 0,
        maxRetries: 2,
        initialized: false,
        async init() {
          if (this.initialized) return;
          this.initialized = true;
          if (!this.dataSourceURL) {
            this.error = 'No data source URL configured';
            return;
          }
          const onReady = () => {
            this.loading = false;
            this.error = null;
            this.loadingMessage = 'Loaded';
            this.loadingProgress = 100;
          };
          window.addEventListener('inspections-data-ready', onReady, { once: false });
          this.cacheName = this.generateCacheName(this.dataSourceURL);
          await this.loadData();
        },
        generateCacheName(url) {
          let hash = 0;
          for (let i = 0; i < url.length; i++) {
            const char = url.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
          }
          return `data-cache-${Math.abs(hash)}`;
        },
        async loadData() {
          this.loading = true;
          this.error = null;
          this.loadingProgress = 2;
          try {
            const cachedData = await this.loadFromCache();
            if (cachedData) {
              this.data = cachedData;
              this.loadingMessage = 'Loading from cache...';
              this.loadingProgress = 100;
              this.loading = false;
              this.refreshDataInBackground();
              if (!window._inspectionsDataDispatched) {
                this.notifyDataReady();
              }
            } else {
              await this.loadFromS3();
            }
          } catch (err) {
            await this.handleError(err);
          } finally {
            if (this.data.length > 0 && !this.error) {
              this.loading = false;
              await this.waitForLoadingTransition();
              if (!window._inspectionsDataDispatched) {
                this.notifyDataReady();
              }
            }
          }
        },
        async waitForLoadingTransition() {
          return new Promise((resolve) => {
            requestAnimationFrame(() => {
              const root = this.$root || document;
              const spinners = root.querySelectorAll('[x-show]');
              let maxDuration = 0;
              const active = [];
              spinners.forEach(el => {
                const style = window.getComputedStyle(el);
                const display = style.display;
                const opacity = style.opacity;
                const dur = style.transitionDuration || '0s';
                const durationMs = parseFloat(dur) * 1000;
                if ((display !== 'none' || opacity !== '0') && durationMs > 0) {
                  active.push({ el, durationMs });
                  maxDuration = Math.max(maxDuration, durationMs);
                }
              });
              if (active.length === 0 || maxDuration === 0) {
                resolve();
                return;
              }
              let doneCount = 0;
              const total = active.length;
              const onDone = () => {
                doneCount++;
                if (doneCount >= total) resolve();
              };
              active.forEach(({ el, durationMs }) => {
                let finished = false;
                const end = (e) => {
                  if (!finished && (e.target === el || el.contains(e.target))) {
                    finished = true;
                    el.removeEventListener('transitionend', end);
                    onDone();
                  }
                };
                el.addEventListener('transitionend', end);
                setTimeout(() => {
                  if (!finished) {
                    finished = true;
                    el.removeEventListener('transitionend', end);
                    onDone();
                  }
                }, durationMs + 120);
              });
            });
          });
        },
        async loadFromS3() {
          const response = await fetch(this.dataSourceURL, {
            mode: 'cors',
            cache: 'no-cache',
            headers: { 'Accept-Encoding': 'gzip' }
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          this.loadingMessage = 'Downloading data...';
          this.loadingProgress = 5;
          const contentLength = response.headers.get('content-length');
          const total = parseInt(contentLength, 10);
          const reader = response.body.getReader();
          const chunks = [];
          let received = 0;
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            received += value.length;
            if (total) {
              const rawProgress = (received / total) * 70;
              const calculatedProgress = Math.min(70, Math.round(rawProgress));
              if (calculatedProgress > this.loadingProgress) {
                this.loadingProgress = calculatedProgress;
                this.loadingMessage = `Downloading data... (${this.loadingProgress}%)`;
              }
            }
          }
          if (this.loadingProgress < 70) this.loadingProgress = 70;
          this.loadingMessage = 'Preparing data...';
          await new Promise(r => setTimeout(r, 50));
          const blob = new Blob(chunks);
          const text = await blob.text();
          if (this.loadingProgress < 80) this.loadingProgress = 80;
          this.loadingMessage = 'Processing data...';
          await new Promise(r => setTimeout(r, 50));
          const parsed = this.parseCSV(text);
          if (this.loadingProgress < 90) this.loadingProgress = 90;
          this.loadingMessage = 'Loading...';
          await new Promise(r => setTimeout(r, 50));
          await this.saveToCache(parsed);
          this.loadingProgress = 100;
          this.data = parsed;
        },
        notifyDataReady() {
          if (!window._inspectionsDataDispatched) {
            window._inspectionsDataDispatched = true;
            window.dispatchEvent(new CustomEvent('inspections-data-ready', {
              detail: { data: this.data }
            }));
          }
          this.loading = false;
          this.loadingProgress = 100;
          this.loadingMessage = 'Loaded';
        },
        parseCSV(text) {
          const records = [];
          let currentRecord = [];
          let currentField = '';
          let inQuotes = false;
          let i = 0;
          while (i < text.length) {
            const char = text[i];
            if (char === '"') {
              if (inQuotes && text[i + 1] === '"') {
                currentField += '"';
                i += 2;
              } else {
                inQuotes = !inQuotes;
                i++;
              }
            } else if (char === ',' && !inQuotes) {
              currentRecord.push(currentField.trim());
              currentField = '';
              i++;
            } else if (char === '\n' && !inQuotes) {
              currentRecord.push(currentField.trim());
              if (currentRecord.some(f => f.length > 0)) records.push(currentRecord);
              currentRecord = [];
              currentField = '';
              i++;
            } else if (char === '\r' && text[i + 1] === '\n' && !inQuotes) {
              currentRecord.push(currentField.trim());
              if (currentRecord.some(f => f.length > 0)) records.push(currentRecord);
              currentRecord = [];
              currentField = '';
              i += 2;
            } else {
              currentField += char;
              i++;
            }
          }
          if (currentField || currentRecord.length > 0) {
            currentRecord.push(currentField.trim());
            if (currentRecord.some(f => f.length > 0)) records.push(currentRecord);
          }
          if (records.length === 0) return [];
          const headers = records[0];
          const data = [];
          const numericSet = new Set(this.numericFields);
          for (let i = 1; i < records.length; i++) {
            const values = records[i];
            if (values.length < headers.length / 2) continue;
            const row = {};
            headers.forEach((header, idx) => {
              let value = values[idx] || '';
              if (numericSet.has(header)) value = parseFloat(value) || null;
              row[header] = value;
            });
            data.push(row);
          }
          return data;
        },
        async loadFromCache() {
          try {
            const db = await this.openDB();
            const tx = db.transaction('dataCache', 'readonly');
            const store = tx.objectStore('dataCache');
            const cached = await store.get(this.cacheName);
            if (!cached) return null;
            const age = Date.now() - cached.timestamp;
            if (age > this.maxCacheAge) return null;
            if (cached.version !== this.cacheVersion) return null;
            return cached.data;
          } catch {
            return null;
          }
        },
        async saveToCache(data) {
          try {
            const db = await this.openDB();
            const tx = db.transaction('dataCache', 'readwrite');
            const store = tx.objectStore('dataCache');
            await store.put({
              id: this.cacheName,
              data,
              timestamp: Date.now(),
              version: this.cacheVersion
            });
          } catch {}
        },
        openDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains('dataCache')) {
                db.createObjectStore('dataCache', { keyPath: 'id' });
              }
            };
          });
        },
        async refreshDataInBackground() {
          try {
            const response = await fetch(this.dataSourceURL, { mode: 'cors', cache: 'no-cache' });
            if (!response.ok) return;
            const text = await response.text();
            const parsed = this.parseCSV(text);
            const currentLen = JSON.stringify(this.data).length;
            const newLen = JSON.stringify(parsed).length;
            if (newLen !== currentLen) {
              this.data = parsed;
              await this.saveToCache(parsed);
              if (!window._inspectionsDataDispatched) {
                this.notifyDataReady();
              } else {
                window.dispatchEvent(new CustomEvent('inspections-data-updated', { detail: { data: parsed } }));
              }
            }
          } catch {}
        },
        async handleError(err) {
          this.retryCount++;
          if (this.retryCount <= this.maxRetries) {
            this.error = `Loading failed. Retrying (${this.retryCount}/${this.maxRetries})...`;
            this.loadingMessage = 'Retrying...';
            const delay = Math.min(1000 * Math.pow(2, this.retryCount - 1), 5000);
            await new Promise(resolve => setTimeout(resolve, delay));
            await this.loadData();
          } else {
            const cachedData = await this.loadFromCache();
            if (cachedData) {
              this.error = 'Using cached data (offline mode)';
              this.data = cachedData;
              this.loading = false;
              this.notifyDataReady();
            } else {
              this.error = `Failed to load data: ${err.message}. Please refresh the page.`;
              this.loading = false;
            }
          }
        },
        async retry() {
          window._inspectionsDataDispatched = false;
          this.retryCount = 0;
          await this.loadData();
        }
      };
    }
</script>

<div x-data="s3DataLoader()" x-init="init()">
  <template x-if="showPopup">
    <div
      x-show="loading || error"
      class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
      x-cloak
    >
      <div class="w-full max-w-md rounded-lg bg-white p-8 shadow-xl">
        <template x-if="loading && !error">
          <div>
            <div class="mb-4 flex items-center justify-center">
              <svg class="h-12 w-12 animate-spin text-yellow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
              </svg>
            </div>
            <h3 class="mb-2 text-center font-sans text-xl font-bold text-black" x-text="loadingMessage"></h3>
            <div class="mb-2 h-3 w-full overflow-hidden rounded-full bg-g-3">
              <div class="h-full rounded-full bg-yellow transition-all duration-300" :style="`width: ${loadingProgress}%`"></div>
            </div>
            <p class="text-center font-sans text-sm text-g-6"><span x-text="loadingProgress"></span>% complete</p>
          </div>
        </template>
        <template x-if="error">
          <div>
            <div class="mb-4 flex items-center justify-center">
              <svg class="h-12 w-12 text-red-7" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
              </svg>
            </div>
            <h3 class="mb-2 text-center font-sans text-xl font-bold text-black">Unable to Load Data</h3>
            <p class="mb-6 text-center font-sans text-sm text-g-6" x-text="error"></p>
            <button @click="retry()" class="w-full rounded-lg border-2 border-yellow-5 bg-yellow px-6 py-3 font-sans text-lg font-bold text-yellow-9 transition hover:bg-yellow-3">Try Again</button>
          </div>
        </template>
      </div>
    </div>
  </template>
  <template x-if="!showPopup">
    <div x-show="loading || error" class="w-full bg-white p-8 shadow md:p-10">
      <template x-if="loading && !error">
        <div>
          <div class="mb-4 flex items-center justify-center">
            <svg class="h-12 w-12 animate-spin text-yellow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
            </svg>
          </div>
          <h3 class="mb-2 text-center font-sans text-xl font-bold text-black" x-text="loadingMessage"></h3>
          <div class="mb-2 h-3 w-full overflow-hidden rounded-full bg-g-3">
            <div class="h-full rounded-full bg-yellow transition-all duration-300" :style="`width: ${loadingProgress}%`"></div>
          </div>
          <p class="text-center font-sans text-sm text-g-6"><span x-text="loadingProgress"></span>% complete</p>
        </div>
      </template>
      <template x-if="error">
        <div>
          <div class="mb-4 flex items-center justify-center">
            <svg class="h-12 w-12 text-red-7" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"/>
            </svg>
          </div>
          <h3 class="mb-2 text-center font-sans text-xl font-bold text-black">Unable to Load Data</h3>
          <p class="mb-6 text-center font-sans text-sm text-g-6" x-text="error"></p>
          <button @click="retry()" class="w-full rounded-lg border-2 border-yellow-5 bg-yellow px-6 py-3 font-sans text-lg font-bold text-yellow-9 transition hover:bg-yellow-3">Try Again</button>
        </div>
      </template>
    </div>
  </template>
</div>
