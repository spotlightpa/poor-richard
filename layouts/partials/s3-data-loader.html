<script>
  window._inspectionsDataDispatched = window._inspectionsDataDispatched || false;
  window._geojsonDataDispatched = window._geojsonDataDispatched || false;

  function s3DataLoader() {
    return {
      dataSourceURL: {{ .Param "data.source" | default "" }},
      geojsonSources: {{ .Param "geojson.sources" | default "[]" }},
      showPopup: {{ .Param "data.popup" | default "false" }},
      cacheVersion: {{ .Param "data.cacheVersion" | default 1 }},
      geojsonCacheVersion: {{ .Param "geojson.cacheVersion" | default 1 }},
      maxCacheAge: {{ .Param "data.maxCacheAge" | default 24 }} * 60 * 60 * 1000,
      delimiter: {{ .Param "data.delimiter" | default "," }},
      numericFields: {{ .Param "data.numericFields" | default "[]" }},
      cacheName: "",
      dbName: "SpotlightPA-DataCache",
      loading: false,
      loadingProgress: 0,
      loadingMessage: "Initializing...",
      error: null,
      data: [],
      geojsonData: {},
      retryCount: 0,
      maxRetries: 2,
      initialized: false,
      totalTasks: 0,
      completedTasks: 0,

      async init() {
        if (this.initialized) return;
        this.initialized = true;

        this.totalTasks = 0;
        if (this.dataSourceURL) this.totalTasks++;
        if (Array.isArray(this.geojsonSources) && this.geojsonSources.length > 0) {
          this.totalTasks += this.geojsonSources.length;
        }

        if (this.totalTasks === 0) {
          this.error = "No data sources configured";
          return;
        }

        const onReady = () => {
          this.loading = false;
          this.error = null;
          this.loadingMessage = "Loaded";
          this.loadingProgress = 100;
        };

        window.addEventListener("inspections-data-ready", onReady, { once: false });

        if (this.dataSourceURL) {
          this.cacheName = this.generateCacheName(this.dataSourceURL);
        }

        await this.loadAllData();
      },

      generateCacheName(url) {
        let hash = 0;
        for (let i = 0; i < url.length; i++) {
          const char = url.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return `data-cache-${Math.abs(hash)}`;
      },

      getFileName(url) {
        const parts = url.split('/');
        const filename = parts[parts.length - 1];
        return filename.replace('.geojson', '');
      },

      updateProgress() {
        if (this.totalTasks === 0) return;
        this.loadingProgress = Math.floor((this.completedTasks / this.totalTasks) * 100);
      },

      async loadAllData() {
        this.loading = true;
        this.error = null;
        this.completedTasks = 0;
        this.loadingProgress = 2;
        this.loadingMessage = "Loading data...";

        try {
          if (this.dataSourceURL) {
            await this.loadData();
          }

          if (Array.isArray(this.geojsonSources) && this.geojsonSources.length > 0) {
            await this.loadAllGeoJSON();
          }

          if (!window._inspectionsDataDispatched) {
            await this.waitForLoadingTransition();
            this.notifyDataReady();
          }

        } catch (err) {
          await this.handleError(err);
        } finally {
          if ((this.data.length > 0 || Object.keys(this.geojsonData).length > 0) && !this.error) {
            this.loading = false;
          }
        }
      },

      async loadAllGeoJSON() {
        const results = {};

        this.loadingMessage = "Loading map data...";

        for (let i = 0; i < this.geojsonSources.length; i++) {
          const url = this.geojsonSources[i];
          const fileName = this.getFileName(url);

          try {
            const cachedData = await this.loadGeoJSONFromCache(url);
            if (cachedData) {
              results[fileName] = cachedData;
            } else {
              const data = await this.fetchGeoJSON(url);
              results[fileName] = data;
              await this.saveGeoJSONToCache(url, data);
            }
          } catch (err) {
            console.error(`Failed to load ${fileName}:`, err);
            const cachedData = await this.loadGeoJSONFromCache(url);
            if (cachedData) {
              results[fileName] = cachedData;
            }
          }

          this.completedTasks++;
          this.updateProgress();
        }

        this.geojsonData = results;
        this.notifyGeoJSONReady();
      },

      async fetchGeoJSON(url) {
        const response = await fetch(url, { mode: "cors", cache: "no-cache" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return await response.json();
      },

      async loadGeoJSONFromCache(url) {
        try {
          const cacheName = this.generateCacheName(url);
          const db = await this.openDB();
          const tx = db.transaction("geojsonCache", "readonly");
          const store = tx.objectStore("geojsonCache");
          const cached = await store.get(cacheName);

          if (!cached) return null;

          const age = Date.now() - cached.timestamp;
          if (age > this.maxCacheAge) return null;
          if (cached.version !== this.geojsonCacheVersion) return null;

          return cached.data;
        } catch {
          return null;
        }
      },

      async saveGeoJSONToCache(url, data) {
        try {
          const cacheName = this.generateCacheName(url);
          const db = await this.openDB();
          const tx = db.transaction("geojsonCache", "readwrite");
          const store = tx.objectStore("geojsonCache");
          await store.put({
            id: cacheName,
            data,
            timestamp: Date.now(),
            version: this.geojsonCacheVersion
          });
        } catch (err) {
          console.error("Failed to save GeoJSON to cache:", err);
        }
      },

      notifyGeoJSONReady() {
        if (Object.keys(this.geojsonData).length === 0) return;

        if (!window._geojsonDataDispatched) {
          window._geojsonDataDispatched = true;
          window.dispatchEvent(new CustomEvent("geojson-data-ready", {
            detail: { data: this.geojsonData }
          }));
        }
      },

      getGeoJSON(name) {
        return this.geojsonData[name] || null;
      },

      async ensureXLSX() {
        if (window.XLSX) return;
        if (this._xlsxPromise) return this._xlsxPromise;
        this._xlsxPromise = new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js";
          s.onload = () => resolve();
          s.onerror = (e) => reject(new Error("Failed to load XLSX library"));
          document.head.appendChild(s);
        });
        return this._xlsxPromise;
      },

      detectType(url, contentType) {
        const u = (url || "").toLowerCase().split("?")[0];
        const ext = u.split(".").pop();
        if (contentType) {
          const ct = contentType.toLowerCase();
          if (ct.includes("sheet") || ct.includes("spreadsheet") || ct.includes("excel")) return "xlsx";
          if (ct.includes("csv")) return "csv";
          if (ct.includes("tsv")) return "tsv";
          if (ct.includes("json")) return "json";
          if (ct.includes("text")) return "csv";
        }
        if (ext === "xlsx" || ext === "xls") return "xlsx";
        if (ext === "csv") return "csv";
        if (ext === "tsv") return "tsv";
        if (ext === "json") return "json";
        return "csv";
      },

      async loadData() {
        this.error = null;

        try {
          const cachedData = await this.loadFromCache();
          if (cachedData) {
            this.data = cachedData;
            this.loadingMessage = "Loading from cache...";
            this.completedTasks++;
            this.updateProgress();
            this.refreshDataInBackground();
          } else {
            await this.loadFromS3();
            this.completedTasks++;
            this.updateProgress();
          }
        } catch (err) {
          throw err;
        }
      },

      async waitForLoadingTransition() {
        return new Promise((resolve) => {
          requestAnimationFrame(() => {
            const root = this.$root || document;
            const spinners = root.querySelectorAll("[x-show]");
            let maxDuration = 0;
            const active = [];
            spinners.forEach(el => {
              const style = window.getComputedStyle(el);
              const display = style.display;
              const opacity = style.opacity;
              const dur = style.transitionDuration || "0s";
              const durationMs = parseFloat(dur) * 1000;
              if ((display !== "none" || opacity !== "0") && durationMs > 0) {
                active.push({ el, durationMs });
                maxDuration = Math.max(maxDuration, durationMs);
              }
            });
            if (active.length === 0 || maxDuration === 0) {
              resolve();
              return;
            }
            let doneCount = 0;
            const total = active.length;
            const onDone = () => {
              doneCount++;
              if (doneCount >= total) resolve();
            };
            active.forEach(({ el, durationMs }) => {
              let finished = false;
              const end = (e) => {
                if (!finished && (e.target === el || el.contains(e.target))) {
                  finished = true;
                  el.removeEventListener("transitionend", end);
                  onDone();
                }
              };
              el.addEventListener("transitionend", end);
              setTimeout(() => {
                if (!finished) {
                  finished = true;
                  el.removeEventListener("transitionend", end);
                  onDone();
                }
              }, durationMs + 120);
            });
          });
        });
      },

      async loadFromS3() {
        const response = await fetch(this.dataSourceURL, { mode: "cors", cache: "no-cache" });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        const contentType = response.headers.get("content-type") || "";
        const type = this.detectType(this.dataSourceURL, contentType);
        this.loadingMessage = "Downloading data...";

        let parsed;
        if (type === "xlsx") {
          const buf = await response.arrayBuffer();
          this.loadingMessage = "Processing data...";
          await this.ensureXLSX();
          parsed = this.parseXLSX(buf);
        } else if (type === "json") {
          const text = await response.text();
          this.loadingMessage = "Processing data...";
          parsed = this.parseJSON(text);
        } else {
          const text = await response.text();
          this.loadingMessage = "Processing data...";
          const delim = type === "tsv" ? "\t" : this.delimiter || ",";
          parsed = this.parseDelimited(text, delim);
        }

        this.loadingMessage = "Loading...";
        await this.saveToCache(parsed);
        this.data = parsed;
      },

      notifyDataReady() {
        try {
        } catch(e) {}

        if (!window._inspectionsDataDispatched) {
          window._inspectionsDataDispatched = true;
          window.dispatchEvent(new CustomEvent("inspections-data-ready", {
            detail: {
              data: this.data,
              geojsonData: this.geojsonData
            }
          }));
        }
        this.loading = false;
        this.loadingProgress = 100;
        this.loadingMessage = "Loaded";
      },

      parseXLSX(arrayBuffer) {
        const wb = XLSX.read(arrayBuffer, { type: "array" });
        const sheetName = wb.SheetNames[0];
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });
        return this.coerceNumeric(rows);
      },

      parseJSON(text) {
        let obj = JSON.parse(text);
        if (Array.isArray(obj)) return this.coerceNumeric(obj);
        if (obj && Array.isArray(obj.data)) return this.coerceNumeric(obj.data);
        return [];
      },

      parseDelimited(text, delim) {
        const records = [];
        let currentRecord = [];
        let currentField = "";
        let inQuotes = false;
        let i = 0;
        while (i < text.length) {
          const char = text[i];
          if (char === '"') {
            if (inQuotes && text[i + 1] === '"') {
              currentField += '"';
              i += 2;
            } else {
              inQuotes = !inQuotes;
              i++;
            }
          } else if (char === delim && !inQuotes) {
            currentRecord.push(currentField);
            currentField = "";
            i++;
          } else if ((char === "\n" || char === "\r") && !inQuotes) {
            if (char === "\r" && text[i + 1] === "\n") i++;
            currentRecord.push(currentField);
            if (currentRecord.some(f => (f + "").trim().length > 0)) records.push(currentRecord);
            currentRecord = [];
            currentField = "";
            i++;
          } else {
            currentField += char;
            i++;
          }
        }
        if (currentField.length || currentRecord.length) {
          currentRecord.push(currentField);
          if (currentRecord.some(f => (f + "").trim().length > 0)) records.push(currentRecord);
        }
        if (!records.length) return [];
        const headers = records[0].map(h => (h + "").trim());
        const out = [];
        for (let r = 1; r < records.length; r++) {
          const rowArr = records[r];
          const row = {};
          headers.forEach((h, idx) => {
            row[h] = (rowArr[idx] ?? "").toString().trim();
          });
          out.push(row);
        }
        return this.coerceNumeric(out);
      },

      coerceNumeric(rows) {
        if (!Array.isArray(rows)) return [];
        const numericSet = new Set(this.numericFields);
        return rows.map(row => {
          const r = {};
          Object.keys(row).forEach(k => {
            let v = row[k];
            if (numericSet.has(k)) {
              if (typeof v === "number") {
                r[k] = v;
              } else {
                const num = parseFloat((v + "").replace(/,/g, ""));
                r[k] = isNaN(num) ? null : num;
              }
            } else {
              r[k] = v;
            }
          });
          return r;
        });
      },

      async loadFromCache() {
        try {
          const db = await this.openDB();
          const tx = db.transaction("dataCache", "readonly");
          const store = tx.objectStore("dataCache");
          const cached = await store.get(this.cacheName);
          if (!cached) return null;
          const age = Date.now() - cached.timestamp;
          if (age > this.maxCacheAge) return null;
          if (cached.version !== this.cacheVersion) return null;
          return cached.data;
        } catch {
          return null;
        }
      },

      async saveToCache(data) {
        try {
          const db = await this.openDB();
          const tx = db.transaction("dataCache", "readwrite");
          const store = tx.objectStore("dataCache");
          await store.put({ id: this.cacheName, data, timestamp: Date.now(), version: this.cacheVersion });
        } catch {}
      },

      openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, 2);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("dataCache")) {
              db.createObjectStore("dataCache", { keyPath: "id" });
            }
            if (!db.objectStoreNames.contains("geojsonCache")) {
              db.createObjectStore("geojsonCache", { keyPath: "id" });
            }
          };
        });
      },

      async refreshDataInBackground() {
        try {
          const response = await fetch(this.dataSourceURL, { mode: "cors", cache: "no-cache" });
          if (!response.ok) return;
          const contentType = response.headers.get("content-type") || "";
          const type = this.detectType(this.dataSourceURL, contentType);
          let parsed;
          if (type === "xlsx") {
            await this.ensureXLSX();
            parsed = this.parseXLSX(await response.arrayBuffer());
          } else if (type === "json") {
            parsed = this.parseJSON(await response.text());
          } else {
            const delim = type === "tsv" ? "\t" : this.delimiter || ",";
            parsed = this.parseDelimited(await response.text(), delim);
          }
          const currentLen = JSON.stringify(this.data).length;
          const newLen = JSON.stringify(parsed).length;
          if (newLen !== currentLen) {
            this.data = parsed;
            await this.saveToCache(parsed);
            if (!window._inspectionsDataDispatched) {
              this.notifyDataReady();
            } else {
              window.dispatchEvent(new CustomEvent("inspections-data-updated", { detail: { data: parsed } }));
            }
          }
        } catch {}
      },

      partyRows() {
        if (!Array.isArray(this.data)) return [];
        return this.data.filter(r => r.Party && r.Party !== "Total");
      },

      totalRegistered() {
        if (!Array.isArray(this.data)) return 0;
        const t = this.data.find(r => r.Party === "Total");
        if (t && typeof t.Total === "number") return t.Total;
        return this.partyRows().reduce((acc, r) => acc + (typeof r.Total === "number" ? r.Total : 0), 0);
      },

      valueFor(party) {
        const r = (this.data || []).find(x => x.Party === party);
        return r && typeof r.Total === "number" ? r.Total : null;
      },

      async retry() {
        window._inspectionsDataDispatched = false;
        window._geojsonDataDispatched = false;
        this.retryCount = 0;
        this.completedTasks = 0;
        await this.loadAllData();
      },

      async handleError(err) {
        this.retryCount++;
        if (this.retryCount <= this.maxRetries) {
          this.error = `Loading failed. Retrying (${this.retryCount}/${this.maxRetries})...`;
          this.loadingMessage = "Retrying...";
          const delay = Math.min(1000 * Math.pow(2, this.retryCount - 1), 5000);
          await new Promise(resolve => setTimeout(resolve, delay));
          this.completedTasks = 0;
          await this.loadAllData();
        } else {
          const cachedData = await this.loadFromCache();
          if (cachedData) {
            this.error = "Using cached data (offline mode)";
            this.data = cachedData;
            this.loading = false;
            this.notifyDataReady();
          } else {
            this.error = `Failed to load data: ${err.message}. Please refresh the page.`;
            this.loading = false;
          }
        }
      }
    };
  }
</script>

<div x-data="s3DataLoader()" x-init="init()">
  <template x-if="showPopup">
    <div
      x-show="loading || error"
      class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
      x-cloak
    >
      <div class="w-full max-w-md rounded-lg bg-white p-8 shadow-xl">
        <template x-if="loading && !error">
          <div>
            <div class="mb-4 flex items-center justify-center">
              <svg
                class="h-12 w-12 animate-spin text-yellow"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
                ></path>
              </svg>
            </div>
            <h3
              class="mb-2 text-center font-sans text-xl font-bold text-black"
              x-text="loadingMessage"
            ></h3>
            <div class="mb-2 h-3 w-full overflow-hidden rounded-full bg-g-3">
              <div
                class="h-full rounded-full bg-yellow transition-all duration-300"
                :style="`width: ${loadingProgress}%`"
              ></div>
            </div>
            <p class="text-center font-sans text-sm text-g-6">
              <span x-text="loadingProgress"></span>% complete
            </p>
          </div>
        </template>
        <template x-if="error">
          <div>
            <div class="mb-4 flex items-center justify-center">
              <svg
                class="h-12 w-12 text-red-7"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fill-rule="evenodd"
                  d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                  clip-rule="evenodd"
                />
              </svg>
            </div>
            <h3 class="mb-2 text-center font-sans text-xl font-bold text-black">
              Unable to Load Data
            </h3>
            <p
              class="mb-6 text-center font-sans text-sm text-g-6"
              x-text="error"
            ></p>
            <button
              @click="retry()"
              class="w-full rounded-lg border-2 border-yellow-5 bg-yellow px-6 py-3 font-sans text-lg font-bold text-yellow-9 transition hover:bg-yellow-3"
            >
              Try Again
            </button>
          </div>
        </template>
      </div>
    </div>
  </template>
  <template x-if="!showPopup">
    <div x-show="loading || error" class="w-full bg-white p-8 shadow md:p-10">
      <template x-if="loading && !error">
        <div>
          <div class="mb-4 flex items-center justify-center">
            <svg
              class="h-12 w-12 animate-spin text-yellow"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                class="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                stroke-width="4"
              ></circle>
              <path
                class="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"
              ></path>
            </svg>
          </div>
          <h3
            class="mb-2 text-center font-sans text-xl font-bold text-black"
            x-text="loadingMessage"
          ></h3>
          <div class="mb-2 h-3 w-full overflow-hidden rounded-full bg-g-3">
            <div
              class="h-full rounded-full bg-yellow transition-all duration-300"
              :style="`width: ${loadingProgress}%`"
            ></div>
          </div>
          <p class="text-center font-sans text-sm text-g-6">
            <span x-text="loadingProgress"></span>% complete
          </p>
        </div>
      </template>
      <template x-if="error">
        <div>
          <div class="mb-4 flex items-center justify-center">
            <svg
              class="h-12 w-12 text-red-7"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fill-rule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                clip-rule="evenodd"
              />
            </svg>
          </div>
          <h3 class="mb-2 text-center font-sans text-xl font-bold text-black">
            Unable to Load Data
          </h3>
          <p
            class="mb-6 text-center font-sans text-sm text-g-6"
            x-text="error"
          ></p>
          <button
            @click="retry()"
            class="w-full rounded-lg border-2 border-yellow-5 bg-yellow px-6 py-3 font-sans text-lg font-bold text-yellow-9 transition hover:bg-yellow-3"
          >
            Try Again
          </button>
        </div>
      </template>
    </div>
  </template>
</div>
